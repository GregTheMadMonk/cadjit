export module cadjit:tree;

import dxx.cstd.fixed;
import std;

namespace cadjit {

template <typename NodeData>
class tree_t {
public:
    using node_data_t = NodeData;

private:
    struct node_t {
        std::shared_ptr<node_t> parent;
        std::shared_ptr<node_t> left, right;
        node_data_t             data;
    }; // <-- struct node_t

public:
    struct iterator_t {
        using iterator_category = std::forward_iterator_tag;
        using difference_type   = std::ptrdiff_t;
        using value_type        = node_t;
        using pointer           = node_t*;
        using reference         = node_t&;

        std::shared_ptr<node_t> ptr;

        iterator_t() : ptr(nullptr) {}
        iterator_t(std::shared_ptr<node_t> p) : ptr(p) {}
        iterator_t(const iterator_t& other) : ptr(other.ptr) {}
        iterator_t& operator=(const iterator_t& other) { this->ptr = other.ptr; return *this; }

        auto& operator++() {
            if (this->ptr->left != nullptr) {
                this->ptr = this->ptr->left;
            } else if (this->ptr->right != nullptr) {
                this->ptr = this->ptr->right;
            } else {
                while (this->ptr != nullptr) {
                    if (this->ptr->parent != nullptr && this->ptr == this->ptr->parent->left) {
                        // Didn't take the right path yet
                        if (this->ptr->parent->right != nullptr) {
                            this->ptr = this->ptr->parent->right;
                            break;
                        } else {
                            this->ptr = this->ptr->parent;
                        }
                    } else {
                        this->ptr = this->ptr->parent;
                    }
                }
            }
            return *this;
        }

        auto operator++(int) {
            const auto ret = *this;
            ++(*this);
            return ret;
        }

        auto& operator*(this auto& self) { return *self.ptr; }

        [[nodiscard]] 
        inline bool operator<=>(const iterator_t&) const = default;
    }; // <-- struct iterator_t

public:
    tree_t(const node_data_t& root_data)
        : root{
            std::make_shared<node_t>(
                node_t{
                    .parent = nullptr,
                    .left   = nullptr,
                    .right  = nullptr,
                    .data   = root_data,
                }
            )
          }
    {}

    [[nodiscard]]
    inline auto& get_root(this auto& self) { return self.root; }

    inline auto push_node(std::shared_ptr<node_t> parent, const node_data_t& data, bool left) {
        (left ? parent->left : parent->right) = std::make_shared<node_t>(
            node_t{
                .parent = parent,
                .left   = nullptr,
                .right  = nullptr,
                .data   = data,
            }
        );

        return (left ? parent->left : parent->right);
    }

    [[nodiscard]]
    inline auto begin() { return iterator_t{ this->root }; }

    [[nodiscard]]
    inline auto begin() const { return iterator_t{ this->root }; }

    [[nodiscard]]
    inline auto end()   { return iterator_t{ nullptr }; }

    [[nodiscard]]
    inline auto end() const   { return iterator_t{ nullptr }; }

private:
    std::shared_ptr<node_t> root;
}; // <-- class tree_t

} // <-- namespace cadjit
